import React, { useEffect, useRef } from "react";

/**
 * 1x1 Open-World Star Chase
 * - 2 jogadores no mesmo teclado (WASD e Setas)
 * - Mundo grande com estrelas leves espalhadas
 * - Câmera dinâmica que enquadra os dois jogadores
 * - Minimapa no canto superior direito
 * - Pontuação por coleta de estrelas
 * - Teclas: P = Pausar/Retomar, R = Reiniciar
 */

export default function StarDuel1x1() {
  const canvasRef = useRef(null);
  const overlayRef = useRef(null);
  const animRef = useRef(0);

  // Game refs (mutáveis sem re-render)
  const worldRef = useRef({ w: 5000, h: 5000 });
  const playersRef = useRef({
    p1: {
      x: 500, y: 500, r: 14, color: "#5eead4", name: "P1",
      keys: { up: false, down: false, left: false, right: false },
    },
    p2: {
      x: 4500, y: 4500, r: 14, color: "#f472b6", name: "P2",
      keys: { up: false, down: false, left: false, right: false },
    },
  });
  const scoresRef = useRef({ p1: 0, p2: 0 });
  const stateRef = useRef({ paused: false });
  const starsRef = useRef([]);
  const camRef = useRef({ x: 0, y: 0, zoom: 1 });

  // Utils
  const rand = (min, max) => Math.random() * (max - min) + min;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  const resetGame = () => {
    const { w, h } = worldRef.current;
    playersRef.current.p1.x = w * 0.25;
    playersRef.current.p1.y = h * 0.25;
    playersRef.current.p2.x = w * 0.75;
    playersRef.current.p2.y = h * 0.75;
    scoresRef.current.p1 = 0;
    scoresRef.current.p2 = 0;
    generateStars();
  };

  const generateStars = (count = 350) => {
    const { w, h } = worldRef.current;
    const stars = [];
    for (let i = 0; i < count; i++) {
      stars.push({ x: rand(0, w), y: rand(0, h), r: rand(1, 2.2) });
    }
    starsRef.current = stars;
  };

  const respawnStar = (s) => {
    const { w, h } = worldRef.current;
    s.x = rand(0, w);
    s.y = rand(0, h);
    s.r = rand(1, 2.2);
  };

  const handleKeys = (e, down) => {
    const p1 = playersRef.current.p1;
    const p2 = playersRef.current.p2;
    switch (e.code) {
      // P1 WASD
      case "KeyW": p1.keys.up = down; break;
      case "KeyS": p1.keys.down = down; break;
      case "KeyA": p1.keys.left = down; break;
      case "KeyD": p1.keys.right = down; break;
      // P2 Setas
      case "ArrowUp": p2.keys.up = down; break;
      case "ArrowDown": p2.keys.down = down; break;
      case "ArrowLeft": p2.keys.left = down; break;
      case "ArrowRight": p2.keys.right = down; break;
      // Pause & Reset (somente onKeyDown)
      case "KeyP": if (down) stateRef.current.paused = !stateRef.current.paused; break;
      case "KeyR": if (down) resetGame(); break;
    }
  };

  const update = (dt) => {
    const speed = 240; // unidades/seg
    const friction = 0.88; // desaceleração suave

    // Movimentação básica
    for (const id of ["p1", "p2"]) {
      const p = playersRef.current[id];
      p.vx = (p.vx || 0) * friction;
      p.vy = (p.vy || 0) * friction;
      const ax = (p.keys.right ? 1 : 0) - (p.keys.left ? 1 : 0);
      const ay = (p.keys.down ? 1 : 0) - (p.keys.up ? 1 : 0);
      p.vx += ax * speed * dt;
      p.vy += ay * speed * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      // Limites do mundo
      const { w, h } = worldRef.current;
      p.x = clamp(p.x, p.r, w - p.r);
      p.y = clamp(p.y, p.r, h - p.r);
    }

    // Coleta de estrelas
    const collectR = 18;
    starsRef.current.forEach((s) => {
      for (const id of ["p1", "p2"]) {
        const p = playersRef.current[id];
        const dx = s.x - p.x;
        const dy = s.y - p.y;
        if (dx * dx + dy * dy < collectR * collectR) {
          scoresRef.current[id] += 1;
          respawnStar(s);
        }
      }
    });
  };

  const updateCamera = (ctx, w, h) => {
    // Enquadra os dois jogadores
    const p1 = playersRef.current.p1;
    const p2 = playersRef.current.p2;
    const minX = Math.min(p1.x, p2.x);
    const maxX = Math.max(p1.x, p2.x);
    const minY = Math.min(p1.y, p2.y);
    const maxY = Math.max(p1.y, p2.y);

    const pad = 160; // margem
    const boxW = Math.max(400, (maxX - minX) + pad);
    const boxH = Math.max(300, (maxY - minY) + pad);

    const zoomX = w / boxW;
    const zoomY = h / boxH;
    const zoom = Math.min(zoomX, zoomY, 2.2); // máximo de zoom-in

    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;

    camRef.current.zoom = zoom;
    camRef.current.x = centerX - (w / (2 * zoom));
    camRef.current.y = centerY - (h / (2 * zoom));

    // Limitar câmera ao mundo
    const { w: W, h: H } = worldRef.current;
    camRef.current.x = clamp(camRef.current.x, 0, Math.max(0, W - w / zoom));
    camRef.current.y = clamp(camRef.current.y, 0, Math.max(0, H - h / zoom));

    ctx.setTransform(zoom, 0, 0, zoom, -camRef.current.x * zoom, -camRef.current.y * zoom);
  };

  const draw = (ctx, w, h) => {
    // Limpa com um espaço "noturno" leve
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = "#0b1220"; // fundo escuro
    ctx.fillRect(0, 0, w, h);

    // HUD (texto) – desenhado em coords de tela
    const scoreText = `P1: ${scoresRef.current.p1}  |  P2: ${scoresRef.current.p2}`;
    ctx.font = "16px ui-sans-serif, system-ui, -apple-system";
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.fillText(scoreText, 16, 28);
    if (stateRef.current.paused) {
      ctx.font = "bold 28px ui-sans-serif, system-ui, -apple-system";
      ctx.fillText("PAUSADO (P)", 16, 60);
    }
    ctx.restore();

    // Câmera
    updateCamera(ctx, w, h);

    // Desenha estrelas do mundo
    ctx.fillStyle = "#cbd5e1"; // estrelas clarinhas
    starsRef.current.forEach((s) => {
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.fill();
    });

    // Brilhos suaves (parallax fake)
    ctx.globalAlpha = 0.12;
    starsRef.current.forEach((s, i) => {
      if (i % 12 === 0) {
        ctx.beginPath();
        ctx.arc(s.x + 10, s.y + 6, s.r * 4, 0, Math.PI * 2);
        ctx.fill();
      }
    });
    ctx.globalAlpha = 1;

    // Jogadores
    for (const id of ["p1", "p2"]) {
      const p = playersRef.current[id];
      // Glow
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 15;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();

      // Borda
      ctx.shadowBlur = 0;
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.6)";
      ctx.stroke();

      // Nome
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system";
      ctx.fillStyle = "#e2e8f0";
      ctx.fillText(p.name, p.x - 10, p.y - p.r - 10);
    }

    // Minimap (coords de tela)
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    const mmSize = 190;
    const pad = 16;
    const mmX = w - mmSize - pad;
    const mmY = pad;
    ctx.fillStyle = "rgba(15,23,42,0.65)";
    ctx.strokeStyle = "rgba(148,163,184,0.8)";
    ctx.lineWidth = 2;
    roundRect(ctx, mmX, mmY, mmSize, mmSize, 14);
    ctx.fill();
    ctx.stroke();

    // Conteúdo do minimapa
    const { w: W, h: H } = worldRef.current;
    const scaleX = mmSize / W;
    const scaleY = mmSize / H;

    // Estrelas leves (pontos rarefeitos para performance)
    ctx.fillStyle = "#94a3b8";
    for (let i = 0; i < starsRef.current.length; i += 10) {
      const s = starsRef.current[i];
      const sx = mmX + s.x * scaleX;
      const sy = mmY + s.y * scaleY;
      ctx.fillRect(sx, sy, 1, 1);
    }

    // Players no minimapa
    const dot = (px, py, color) => {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(mmX + px * scaleX, mmY + py * scaleY, 3, 0, Math.PI * 2);
      ctx.fill();
    };
    dot(playersRef.current.p1.x, playersRef.current.p1.y, "#5eead4");
    dot(playersRef.current.p2.x, playersRef.current.p2.y, "#f472b6");

    // Retângulo da câmera no minimapa
    const z = camRef.current.zoom;
    const vw = (w / z) * scaleX;
    const vh = (h / z) * scaleY;
    const vx = mmX + camRef.current.x * scaleX;
    const vy = mmY + camRef.current.y * scaleY;
    ctx.strokeStyle = "rgba(248,250,252,0.9)";
    ctx.lineWidth = 1.5;
    ctx.strokeRect(vx, vy, vw, vh);

    ctx.restore();
  };

  const roundRect = (ctx, x, y, w, h, r) => {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");

    const onResize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    onResize();
    window.addEventListener("resize", onResize);

    // Input
    const down = (e) => handleKeys(e, true);
    const up = (e) => handleKeys(e, false);
    window.addEventListener("keydown", down);
    window.addEventListener("keyup", up);

    // Init
    generateStars();
    resetGame();

    let last = performance.now();
    const loop = (t) => {
      const dt = Math.min(0.033, (t - last) / 1000); // cap 30ms
      last = t;
      if (!stateRef.current.paused) update(dt);
      draw(ctx, canvas.width, canvas.height);
      animRef.current = requestAnimationFrame(loop);
    };
    animRef.current = requestAnimationFrame(loop);

    return () => {
      cancelAnimationFrame(animRef.current);
      window.removeEventListener("resize", onResize);
      window.removeEventListener("keydown", down);
      window.removeEventListener("keyup", up);
    };
  }, []);

  return (
    <div className="w-screen h-screen bg-slate-900 select-none overflow-hidden">
      <canvas ref={canvasRef} className="w-full h-full block" />

      {/* Overlay de instruções */}
      <div ref={overlayRef} className="pointer-events-none absolute inset-x-0 top-3 flex justify-center">
        <div className="bg-slate-800/70 text-slate-100 backdrop-blur rounded-2xl shadow-lg px-4 py-2 text-sm flex gap-4">
          <div className="hidden sm:block">Jogo 1x1 – Mundo Aberto (Estrelas)</div>
          <div><span className="font-semibold">P1</span>: W A S D</div>
          <div><span className="font-semibold">P2</span>: ↑ ↓ ← →</div>
          <div><span className="font-semibold">P</span>: Pausar</div>
          <div><span className="font-semibold">R</span>: Reiniciar</div>
          <div>⭐ Colete estrelas para pontuar</div>
        </div>
      </div>
    </div>
  );
}
